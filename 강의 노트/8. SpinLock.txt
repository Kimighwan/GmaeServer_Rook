8. SpinLock

쓰레드 2개 만들어서 뮤텍스 1개로
다른 함수 2개에서 해당 뮤텍스로 lock을 걸어서
동시에 쓰레드를 작업을 시키면 lock으로 인해
정상적으로 결과값이 나오는게 저번 강의 까지의 내용

--------------------------

이번에는  mutex가 아니라 우리가 자체적으로 구현한 그런 클래스로
위 내용을 바꿔치기해서 똑같이 결과값이 나오냐?

SpinLock 클래스 1개 만들고  
락을 걸어주는 함수, 락을 풀어주는 함수 1개씩 만들어준다.

보통 아무 배경지식이 없다면
prviate bool 변수 lock 1개 만들어주고

스핀락이니 계속 while 돌아주면서 들어가지면 lock잠구고 작업이 끝나면 풀어줄 것이다.
unlock은 그냥 락을 풀어줄 것이다.

원래 함수에서 lock_guard<mutex> guard(m); 를 사용했지만
뮤텍스대신 우리 자체 클래스를 넣고 해당 객체 즉, 스핀락을 사용하면

정상적인 결과값이 아니다.



왜 그런가????????
스핀락(존버 메타)
사실을 락을 가지고 작업안으로 들어가서 락을 잠구는 것이 한 번에 이루어져야 맞는 것인데

위 상황은 딱히 그러한 제한이 없기 때문에 
거의 동시에 두 개 이상의 쓰레드가 락을 잡고 서로 잠구는 거다
 ㄴ 1개의 쓰레드가 락을 소유하고 잠구기 전에 다른 쓰레드가 해당 락을 가져가서 또 잠굴려고 한다.
그러면 결국에는 결과값이 서로 덮어지는 그런 문제가 일어난다.

즉 락을 소유하는 것과 락을 잠구는 작업이 원자적으로 이루어져야 한다.

그럼 어떻게 해결하냐????????
위에서 계속 존버하는 while문 -> 계속 lock이 풀렸는지 확인하는 작업과
lock을 잠구는 작업이 한 번에 묶어서 동작하게끔 유도해야 한다.

코드를 아토믹으로 묶어주는 그런 함수들이 있다
그런것들을 CAS(Compare and Swap) 계열의 함수라고 한다.
운영체제에 따라 많은 함수들이 있는데

그냥 atiomic을 사용하면 원자적으로 사용하겠다 그런 의미이다
여기에 묶여있는 함수가 있는데(메서드) 중요하다!!!!!!
 ㄴ _locked.compare_exchange_strong()    -> 사용 환경에 따라 살짝 다르긴 한데 c++ 에서 보면
  ㄴ 함수 원형을 보면 bool를 리턴하고 매개변수로 bool 변수인 expected와 desired를 받는다
   ㄴ expected - 예상되는, 기대하는 // desired - 원하는

그러면 _locked.compare_exchange_strong(expected, desired); 이렇게 사용을 하는데
lock의 값이 expected라는 값으로 예상을 하고 있다
그 예상 값이 맞다면 lock을 desired값으로 바꿔준다.

CAS(Compare and Swap) 의사 코드로 풀어서 본다면

// CAS 의사 코드
if (_locked == expected)   // 이렇게 locked랑 expected가 같을 수 있고
{
    expected = _locked; // ???? 밑에 이전에 이렇게 넣어주는데 이건 이해가 안됨
    _locked = desired;
    return true;
}
else                       // 다를 수 있지?
{
    expected = _locked; // ???? 밑에 이전에 이렇게 넣어주는데 이건 이해가 안됨
    return false;
}

이 해당 작업이 compare_exchange_strong(expected, desired) 함수가 원자적으로 수행한다

여기서 유심히 보면 locked가 false라고 한다면(expected로 기대된다면)
desired인 true로 바꿔주는 상황이다 -> 화장실 들어가면 문을 잠굼../

이렇게 기대하는데로 작업이 되면 true를 반환하고
아니면 누군가 이미 lock을 소유해서 lock을 소유를 못하면 false를 반환하게 된다.

그래서 다음과 같이 락을 소유하지 못했다면 계속해서 존버를 하는 것이고
while (_locked.compare_exchange_strong(expected, desired) == false) 
{

}

1가지 조심해야 할 점이
성공하건 실패하건 상관없이 기본적으로 
expected 값이 우리가 처음에 설정한 값이 아닌 
locked 코드가 expected 쪽으로 들어간다
함수 원형을 보면 expected는 &로 참조를 하고 있는 것을 볼 수 있음
 ㄴ 그래서 계속 값이 바뀌기 때문에 우리가 원하는 값으로 매번 바꿔주면 된다.

 while (_locked.compare_exchange_strong(expected, desired) == false) 
 {
     expected = false;
 }


이러면 진정으로 우리가 원한 상호 베타적으로 락을 사용해 코드가 작동한다.

마지막으로 스핀 락이 효율적인가???
유저 모드에서 계속 뺑뺑이를 돌며 시도하는 것이 시간이 짧다면 효율적이지만

그게 아니라 정말 몇시간 동안 락을 소유한다면 계속 무한정 실행하는 것은 무식한 것 -> cpu 점유율 올라감
 ㄴ 해당 스레드가 다른 작업을 할 수 있는데 계속 묶여있는 것이니 비효율적인거지

만약 컨텍트 스위칭이 되어 다른 친구에서 나의 실행 소유권을 넘겨주면 cpu 점유율이 낮아지면서 
그 다른 친구가 적절히 잘 활용하지만
  계속 뻉뺑이를 돈다면 쓸데없이 낭비하는 것이지

계속 시도하는 것이 스핀락의 특징이지만
무한 루프를 돌면 cpu 점유율이 높아진다는 특징도 있다
















