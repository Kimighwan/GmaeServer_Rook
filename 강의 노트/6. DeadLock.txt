데드락이 발생하는 상황 여러가지지만
널포인터를 참조해서 서버가 다운되는 일이 많이 발생

오늘 실습에선 UserManager클래스와 AccountManager클래스 2개를 사용한다
유저와 계정을 관리하는 클래스들...

계정을 토대로 캐릭터를 받아오는 과정이 있는데 그것이 AccountManager클래스 

우선 Account라는 클래스가 있다고 가정하고
이것은 간단하게 테스트하는 아이디, 해당 계정 이름, 생성일자 등
정보가 들어갈것이다.

AccountManager는 싱글톤으로 언제 어디서든 쉽게 꺼낼 수 있고

GetAccount 함수는 계정 id를 받아 무언가 뱉어주는 기능이라고 가정하자.
실질적으로 멀티스레드에서 동작해야해서 멤버변수 mutex를 가진다.

또한 필요한 정보들도 private 멤버변수들로 
멀티스레드 환경에서 작동하기 위해 lock변수를 가지고 해당 변수들을 참조해야함

ProcessLogin 함수를 만들어서 AccountManager를 이용해 로그인하는 코드를
만든다고 가정하자

보니깐 .h에서 선언만하고 정의는 .cpp에서 하더라..


이렇게 UserManager도 비슷한 느낌으로 만들것이다.

여기까지는 딱히 어려운 부분이 없다

이제 복잡해지는데

어카운터매니저에서 돌아가서
이제 로그인을 할 때 어카운트에 관련된 유저들을 로드하고 유저 매니저에 저장하고
그런 기능들이 필요하다고 가정하자

어카운트 프로세스로그인 함수에서 account에서 사용하는 mutex1개
 그다음 유저매니저에 접근해서 유저 정보를 가져오는 기능에서 mutex 1개 해서 총 2개를 사용하는데
이렇게 2개의 락을 동시에 잡아야하는 경우가 종종 생긴다.

그런데 이제는 유저 매니저에도 마찬가지로 프로세스세이브 함수에서 
mutex를 2번 잡는 경우가 생긴다고 가정하자


이제 테스트를 위해 GameServer.cpp로 돌아가서 간단한 스레드 2개만든다.

그러면 계속 대기하는 상태가 생긴다.

lock을 잡을려고 하지만 다른쪽에서 이미 lock을 잡아버림
서로가 서로를 기다리는 상황 -> 데드락
이러면 각 스레드가 교착상태에 빠져 작업을 하지 못한다

원인&해결법
경쟁하는 상황을 발생시키지 않는다
 1. 2개의 lock을 가지고 노는데 그 lock을 가지는 순서, 규칙을 정하면
     서로 다른 lock을 가진체 상대가 가진 lock을 계속 기다리는 상황이 발생하지 않는다.
==> 이론상으로 그렇긴한데
 사실 모든 경우에 대해서 순서를 맞추는 것은 어렵다.

그리고 테스트할 때는 문제가 없다가 라이브에서 동접이 많아질 때만 극악의 확률로 터질 수 있다.
그럼 개발단계에선 해당 버그를 잡기는 어렵다.

실수를 줄이는 방법이 몇가지 있다.

락사이에 순서를 맞추기 위해 락끼리 순서를 정하는 것이다.
 하지만 이도 우리가 직접 구현하는 것이고 모든 순서에 대해서 관리하기는 어렵다

결국 데드락을 신경쓰면서 구현해야 하고 라이브때 터지면 욕을 먹지만 명확한 이유이기 때문에
수정은 쉽다.

















