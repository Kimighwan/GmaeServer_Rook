이벤트를 이용한 동기화 방법

사실 이벤트가 락에서만 사용하는 개념이아니라
광범위 하게 사용된다

이벤트가 나온 이유는?
갑질 메타
직원한테 부탁해서 직원이 중재해주는 상황임
직원은 커널에 해당한다
우리 끼리 쓰레드의 순서 보장이 되지 않아서
커널 - 직원한테 순서 보장을 해달라고 요청하는 것이다

c#은 오토 리셋 이벤트랑 메뉴얼과 메뉴얼 리셋 이벤트 두 가지로 클래스로 구분되어 있지만
c++ window API는 인자에 따라 위 2개가 결정된다.

그래서 이벤트란? t/f을 가지는 단순한 그런 객체라고 생각하자 
이 상태를 가지고 계속 진행할 지 못하는지 판별할 것이다.

화장실이 언제 빌지 모르는 상태에서 무작정 기다릴 수 없으니
내 자리로 돌아가서 관리자에게 화장실이 비면 그 때 불러줘 부탁하는 상황이다.

이벤트를 만들어주면 파란불 빨간불 마냥 두 가지 상태가 있다
시그널이 꺼져있는 상태 / 켜져있는 상태
꺼져있는 상태에서 켜지게되면 기다리고 있던 친구를 불러준다

파란불로 키는 거는 누가 해주냐? 화장실을 사용중이던 사람이 해주는 것이다.
이벤트에 접근해서 상태를 변경해준다.

장점을 생각해보면
하염없이 대기하면 쓸데없이 자원을 낭비하는 게 아닌 그나마 효율적임

단점은 결국은 제 3자인 커널모드로 돌아와서 추가적인 리소스가 필요해서
고지고때로 남발할 수 없고
어느 정도 대기를 해야 되는 상황이 확실하다고 할 때 사용하면 좋다

스핀락에 비해 어떠한 특징들이 있는지 확실하게 숙지하는 것이 중요

우선 이벤트를 사용하기 위해서 windows.h를 include 해서 테스트를 해보자

예시 1번) 한 쪽에서 100ms마다 데이터를 큐에 밀어 넣기

한쪽 스레드에서는 데이터를 계속 만들거고
 ㄴ 상황 예시 -> 클라에서 데이터를 수신받아 큐에 밀어넣고

다른 쪽 스레드는 생성된 데이터를 꺼내서 소모하는 그런 역할을 할 거다
 ㄴ 상황 예시 -> 게임 컨텐츠를 관리하는 스레드에서 해당 패킷과 관련된 내용을 추출해서 사용

예시 2번) 이번에는 진짜 어쩌다가 한 번씩 데이터를 추가하는 상황
위에선 100ms 가 아니라 큰 숫자라면, 그니깐 10000000ms 정말로 가끔 데이터를 주는 상황일 때는
반대쪽에서 그걸 처리하는 스레드는 해당 상황을 모르기 있기 때문에
결국 소비하는 쪽은 무한 루프를 돌면서 계속 체크를 할 것이고
공용 데이터라 계속 락을 잡는 것도 아쉽다
 ㄴ 데이터도 없는데 소비할려고 데이터가 있는 지 체크하는 뺑뺑이 작업은 비효율적이다.

=> 그래서 매번 체크하는 것이 아닌 데이터가 있을 때만 알려주세요 라는 방법이 좋을 수 있다.
 ㄴ 이걸 테스트 하기 위해 오늘은 Event를 활용해 볼 것이다.

::CreateEvent() 라고 window API를 사용할 것인데 매개변수가 4개다
첫번째는 보안속성과 관련있는데 지금은 상관없으니 null 넣고
두번째는 메뉴얼 리셋이라고 분류형 값을 받는다
 ㄴ 수동으로 리셋할 것이냐, 자동으로 리셋할 것이냐 선택하는 것임
 ㄴ True이면 수동 리셋 / False이면 자동 리셋
세번째는 Initial State라고 이벤트의 초기 상태를 받는다.
 ㄴ true이면 signal / false이면 non-signal 아까 말한 빨간불 파란불 둘 중 하나로 초기 셋팅을 하는 것이다.
마지막은 필수적이지 않아서 그냥 NULL로 넘겨준다

이렇게 CreateEvent를 호출하면 유저레벨에서 마음대로 처리할 수 있는 게 아니고
이벤트 자체가 커널 쪽에 가서 커널에서 만들어주는 아이이기 때문에
커널 오브젝트라고 말하기도 한다

이 함수가 HANDLE 이라는 것은 반환하는데
정수가 들어가 있는데 일종의 번호표라고 생각하면 된다.
커널쪽에서 해당 이벤트를 이용해서 뭔가 작업을 할 때
이 정수를 가지고 어떤 이벤트인지 구별을 한다 - 식별자

우리가 new를 이용해 메모리를 할당하면 delete를 해주는 것 처럼
CloseHandle()을 호출해 핸들을 닫아주는 게 좋다.

커널 오브젝트라고 말했는데 그냥 커널에서 관리하는 오브젝트다.
이 커널 오브젝트를 관리하기 위해 뭔가 할당되는 이련의 메모리가 있다.

공통적으로 커널 오브젝트가 가지고 있는 속성들이 있는데
Usage Count라고 해당 오브젝트를 몇 명이 사용하고 있는지?
Signal/Non-Signal 상태도 가지고 있다

지금 보는 이벤트는 다른 이벤트에 비해 상대적으로 가볍다.

초기로 시그널을 껐는데
이제 데이터를 생성하는 스레드 쪽에서 그냥 데이터만 큐에 밀어넣었지만
이제는 SetEvent()라는 함수로 Signal()로 바꿔주세요라고 요청하는 의미인 함수를 호출하면
Signal로 바뀌게 된다.

그러면 데이터를 소비하는 스레드에서는
::WaitForSingleObject(handle, INFINITE); 함수를 이용하여 대기를 할 것이다
 ㄴ 두 번째 매개변수로 대기시간을 설정할 수 있다.

원래는 무한 뺑뺑이를 돌면서 확인을 했지만
handle을 이용해서 커널 오브젝트의 signal 상태를 봐서 상태에 따라 작동할 것이다.
그래서 아랫부분이 무한정 반복되는 것이 아니다.

우리는 초기 설정은 수동 메뉴 리셋으로 설정했는데

자동 리셋 상태라면 WaitForSingleObject에서 잠든 상태에서 signal이 켜지면 
signal을 받았으니 커널이 데이터 소비하는 스레드로 복원을 하여 작업을 하고 
여기서 작업을하면 Non-Signal로 자동으로 변경된다.

만약 True로 설정하여 수동 리셋이라면
::ResetEvent(handle); 함수를 이용하여 signal을 꺼야한다.

어떤 장점이 있냐면
지금은 하나의 프로그램 내부에서만 서로 동기화 작업을 하지만
다른 프로그램 끼리도 동기화 작업을 이런 커널 오브젝트를 활용하면 가능하다.
